import { useRef, useState, useEffect } from "react"
import { Mesh, Shape, Vector2, Vector3, Curve, BoxGeometry, EdgesGeometry, WireframeGeometry } from "three"
import { Canvas, useFrame } from "@react-three/fiber"
import { ParametricGeometry, TextGeometry, FontLoader, Font } from "three/examples/jsm/Addons.js"

type ShapeProps = {
  position?: [number, number, number]
  color?: string
}

/**
 * a box
 */
function Box({
  position = [0, 0, 0],
  color = "white",
  width = 0.5,
  height = 0.5,
  depth = 0.5,
}: ShapeProps & { width?: number; height?: number; depth?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <boxGeometry args={[width, height, depth]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a flat circle
 */
function Circle({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <circleGeometry args={[radius, 32]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a cone
 */
function Cone({
  position = [0, 0, 0],
  color = "white",
  radius = 0.5,
  height = 1,
}: ShapeProps & { radius?: number; height?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <coneGeometry args={[radius, height, 32]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a cylinder
 */
function Cylinder({
  position = [0, 0, 0],
  color = "white",
  radiusTop = 0.5,
  radiusBot = 0.5,
  height = 1,
}: ShapeProps & { radiusTop?: number; radiusBot?: number; height?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <cylinderGeometry args={[radiusTop, radiusBot, height, 32]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a dodecahedron
 */
function Dodecahedron({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <dodecahedronGeometry args={[radius]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * An extruded 2d shape with optional bevelling. Here we are extruding a heart shape.
 */
function Extrude({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const shape = new Shape()
  shape.moveTo(0, 0)
  shape.bezierCurveTo(-0.25, -0.5, -0.75, 0, 0, 0.75) // Left half of heart
  shape.bezierCurveTo(0.75, 0, 0.5, -0.5, 0, 0) // Right half of heart
  return (
    <mesh ref={ref} position={position}>
      <extrudeGeometry
        args={[shape, { depth: 0.1, bevelEnabled: true, bevelSegments: 1, bevelSize: 0.1, bevelThickness: 0.1 }]}
      />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a icosahedron
 */
function Icosahedron({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <icosahedronGeometry args={[radius]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a shape generated by spinning a line.
 * Examples would be: lamps, bowling pins, candles, candle holders, wine glasses, drinking glasses, etc... You provide the 2d silhouette as series of points and then tell three.js how many subdivisions to make as it spins the silhouette around an axis.
 */
function Lathe({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const points = []
  for (let i = 0; i < 10; i++) {
    points.push(new Vector2(Math.sin(i * 0.2) * 0.5, (i - 5) * 0.1))
  }
  return (
    <mesh ref={ref} position={position}>
      <latheGeometry args={[points, 16]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a octahedron
 */
function Octahedron({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <octahedronGeometry args={[0.5]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a surface geometry generated by providing a function that takes a 2D point from a grid and returns the corresponding 3d point.
 */
function Parametric({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  function klein(v: number, u: number, target: Vector3) {
    u *= Math.PI
    v *= 2 * Math.PI
    u = u * 2
    let x
    let z
    if (u < Math.PI) {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v)
      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v)
    } else {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI)
      z = -8 * Math.sin(u)
    }
    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v)
    target.set(x, y, z).multiplyScalar(0.05)
  }

  return (
    <mesh ref={ref} position={position}>
      <primitive object={new ParametricGeometry(klein, 25, 25)} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a plane
 */
function Plane({
  position = [0, 0, 0],
  color = "white",
  width = 1,
  height = 1,
}: ShapeProps & { width?: number; height?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <planeGeometry args={[width, height]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * Takes a set of triangles centered around a point and projects them onto a sphere
 */
function Polyhedron({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const verticesOfCube = [-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1]
  const indicesOfFaces = [
    2, 1, 0, 0, 3, 2, 0, 4, 7, 7, 3, 0, 0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 6, 6, 7, 4,
  ]
  return (
    <mesh ref={ref} position={position}>
      <polyhedronGeometry args={[verticesOfCube, indicesOfFaces, radius]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a 2d disc with a hole in the center
 */
function Ring({
  position = [0, 0, 0],
  color = "white",
  innerRadius = 0.25,
  outerRadius = 0.5,
}: ShapeProps & { innerRadius?: number; outerRadius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <ringGeometry args={[innerRadius, outerRadius, 32]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a 2d outline that gets triangulated. Here we are drawing a heart shape.
 */
function ShapeGeometry({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const shape = new Shape()
  shape.moveTo(0, 0)
  shape.bezierCurveTo(-0.25, -0.5, -0.75, 0, 0, 0.75) // Left half of heart
  shape.bezierCurveTo(0.75, 0, 0.5, -0.5, 0, 0) // Right half of heart
  return (
    <mesh ref={ref} position={position}>
      <shapeGeometry args={[shape]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a sphere
 */
function Sphere({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <sphereGeometry args={[radius, 32, 32]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a tetrahedron
 */
function Tetrahedron({ position = [0, 0, 0], color = "white", radius = 0.5 }: ShapeProps & { radius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <tetrahedronGeometry args={[radius]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * 3d text generated from a 3d font and a string
 */
function Text({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  const [font, setFont] = useState<Font | null>(null)
  const [loading, setLoading] = useState(true)

  useFrame(() => {
    // Only update rotation if ref.current exists
    if (ref.current) {
      ref.current.rotation.x += 0.01
      ref.current.rotation.y += 0.01
    }
  })

  useEffect(() => {
    const fontLoader = new FontLoader()
    // Load a font from the Three.js examples
    fontLoader.load(
      "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
      (loadedFont) => {
        setFont(loadedFont)
        setLoading(false)
      },
      // onProgress callback
      (xhr) => {
        console.log((xhr.loaded / xhr.total) * 100 + "% loaded")
      },
      // onError callback
      (err) => {
        console.error("An error happened during font loading:", err)
        setLoading(false)
      }
    )
  }, [])

  if (loading || !font) {
    return <mesh position={position} />
  }

  return (
    <mesh ref={ref} position={position}>
      <primitive
        object={(() => {
          const textGeometry = new TextGeometry("Three", {
            font,
            size: 0.15,
            depth: 0.1,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.01,
            bevelSize: 0.001,
            bevelSegments: 5,
          })
          // Center the geometry so it rotates around its center
          textGeometry.computeBoundingBox()
          const centerOffset = textGeometry.boundingBox!.getCenter(new Vector3())
          textGeometry.translate(-centerOffset.x, -centerOffset.y, -centerOffset.z)
          return textGeometry
        })()}
      />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a torus
 */
function Torus({
  position = [0, 0, 0],
  color = "white",
  radius = 0.5,
  tubeRadius = 0.25,
}: ShapeProps & { radius?: number; tubeRadius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <torusGeometry args={[radius, tubeRadius, 16, 48]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a torus knot
 */
function TorusKnot({
  position = [0, 0, 0],
  color = "white",
  radius = 0.5,
  tubeRadius = 0.2,
}: ShapeProps & { radius?: number; tubeRadius?: number }) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  return (
    <mesh ref={ref} position={position}>
      <torusKnotGeometry args={[radius, tubeRadius, 16, 48]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * a circle traced down a path
 */
function Tube({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  class CustomSinCurve extends Curve<Vector3> {
    scale: number
    constructor(scale: number) {
      super()
      this.scale = scale
    }
    getPoint(t: number) {
      const tx = t * 3 - 1.5
      const ty = Math.sin(2 * Math.PI * t)
      const tz = 0
      return new Vector3(tx, ty, tz).multiplyScalar(this.scale)
    }
  }
  const path = new CustomSinCurve(0.5)
  return (
    <mesh ref={ref} position={position}>
      <tubeGeometry args={[path, 64, 0.05, 8, false]} />
      <meshStandardMaterial color={color} />
    </mesh>
  )
}

/**
 * A helper object that takes another geometry as input and generates edges only if the angle between faces is greater than some threshold. For example if you look at the box at the top it shows a line going through each face showing every triangle that makes the box. Using an EdgesGeometry instead the middle lines are removed. Adjust the thresholdAngle below and you'll see the edges below that threshold disappear.
 */
function Edges({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const size = 0.5
  const widthSegments = 2
  const heightSegments = 2
  const depthSegments = 2
  const boxGeometry = new BoxGeometry(size, size, size, widthSegments, heightSegments, depthSegments)
  const geometry = new EdgesGeometry(boxGeometry)
  return (
    <mesh ref={ref} position={position}>
      <primitive object={geometry} />
      <lineBasicMaterial color={color} />
    </mesh>
  )
}

/**
 * Generates geometry that contains one line segment (2 points) per edge in the given geometry. Without this you'd often be missing edges or get extra edges since WebGL generally requires 2 points per line segment. For example if all you had was a single triangle there would only be 3 points. If you tried to draw it using a material with wireframe: true you would only get a single line. Passing that triangle geometry to a WireframeGeometry will generate a new geometry that has 3 lines segments using 6 points..
 */
function Wireframe({ position = [0, 0, 0], color = "white" }: ShapeProps) {
  const ref = useRef<Mesh>(null!)
  useFrame(() => ((ref.current.rotation.x += 0.01), (ref.current.rotation.y += 0.01)))
  const size = 0.5
  const widthSegments = 2
  const heightSegments = 2
  const depthSegments = 2
  const boxGeometry = new BoxGeometry(size, size, size, widthSegments, heightSegments, depthSegments)
  const geometry = new WireframeGeometry(boxGeometry)
  return (
    <mesh ref={ref} position={position}>
      <primitive object={geometry} />
      <lineBasicMaterial color={color} />
    </mesh>
  )
}

export default function Primitives() {
  return (
    <div className="h-screen bg-black">
      <Canvas>
        <ambientLight intensity={0.5} />
        <Box position={[-2, 2, 0]} color={"hotpink"} />
        <Circle position={[-1, 2, 0]} color={"hotpink"} />
        <Cone position={[0, 2, 0]} color={"hotpink"} />
        <Cylinder position={[1, 2, 0]} color={"hotpink"} />
        <Dodecahedron position={[-1, 1, 0]} color={"hotpink"} />
        <Icosahedron position={[0, 1, 0]} color={"hotpink"} />
        <Octahedron position={[1, 1, 0]} color={"hotpink"} />
        <Plane position={[-3, -1, 0]} color={"hotpink"} />
        <Ring position={[1, 0, 0]} color={"hotpink"} />
        <Extrude position={[-1, 0, 0]} color={"red"} />
        <Lathe position={[0, 0, 0]} color={"orange"} />
        <Parametric position={[-2, 0, 0]} color={"lime"} />
        <Polyhedron position={[-1, 0, 0]} color={"blue"} />
        <ShapeGeometry position={[0, -0, 0]} color={"purple"} />
        <Sphere position={[2, -0, 0]} color={"hotpink"} />
        <Tetrahedron position={[1, -1, 0]} color={"hotpink"} />
        <Text position={[0, -1, 0]} color={"hotpink"} />
        <Torus position={[-1, -1, 0]} color={"hotpink"} />
        <TorusKnot position={[-1, -2, 0]} color={"hotpink"} />
        <Tube position={[0, -2, 0]} color={"cyan"} />
        <Edges position={[1, -2, 0]} color={"hotpink"} />
        <Wireframe position={[2, -2, 0]} color={"hotpink"} />
      </Canvas>
    </div>
  )
}
